<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SRFI 184: define-record-lambda</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
    <style>
     dt {
       font-family: monospace;
       margin: 0.5em 0;
     }
     em {
       font-family: serif;
       font-size: 120%;
     }
     .references a {
       display: block;
       margin: 0.5em 0;
     }
     .references td:first-child {
       vertical-align: top;
       width: 5em;
     }
    </style>
  </head>

<body>

<h1>Title</h1>

define-record-lambda

<h1>Author</h1>

Joo ChurlSoo

<h1>Status</h1>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+184+at+srfi+dotschemers+dot+org">srfi-184@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-184">archive</a>.</p>
<ul>
  <li>Received: 2020/2/21</li>
  <li>60-day deadline: 2020/4/22</li>
  <li>Draft #1 published: 2020/2/22</li>
</ul>

<h1>Abstract</h1>

<p>This SRFI introduces a macro, DEFINE-RECORD-LAMBDA, that defines a
  set of procedures, that is, a group of constructors and a predicate.
  The constructors also make a group of procedures, namely record
  lambdas, that have no explicit field accessors and mutators.  They
  can have various kinds of fields, such as common fields, required
  fields, optional fields, automatic fields, read-only fields,
  read-write fields, invisible fields, immutable fields, and virtual
  fields.</p>

<h1>Changes from SRFI 100</h1>

<p>This SRFI is based on <a href="https://srfi.schemers.org/srfi-100/">SRFI
  100</a>.  Unlike the define-lambda-object of SRFI 100:</p>

<ol>
  <li>The inheritance property has been removed because it was
    ineffective and superfluous.</li>
  <li>The record lambda uses field indices or symbolized field names
    to identify fields according to the constructors.</li>
  <li>The field sequence has been changed.</li></ol>

<h1>Rationale</h1>

<p>A record lambda created by a constructor procedure is a procedure
  whose first argument is a field index or symbolized field name that
  is used to identify fields.  It depends on the constructor.  The
  record lambda plays the role of the accessor and mutator of each
  field and makes the explicit or implicit accessors and mutators
  unnecessary.  In addition, this reduces the role of the predicate
  procedure.</p>

<p>This macro works not only as DEFINE-RECORD-TYPE with required
  fields but also as DEFSTRUCT of Common Lisp with optional fields.
  Each field except required fields can be used as a procedure that
  changes the values of the other fields.  As a result, the record
  lambda itself has data and methods as well as their accessors and
  mutators.</p>

<h1>Specification</h1>
<pre>
(define-record-lambda &lt;group&gt; &lt;field spec&gt;)

&lt;field spec&gt; --&gt; &lt;common field&gt;* &lt;required field&gt;* &lt;optional field&gt;* &lt;automatic field&gt;*

&lt;common field&gt; --&gt;
	|  (,@&lt;field&gt;  &lt;default&gt;)	;read-only    automatic common field
	| ((,@&lt;field&gt;) &lt;default&gt;)	;read-write   automatic common field
	| (',@&lt;field&gt;  &lt;default&gt;)	;immutable    automatic common field
	| (`,@&lt;field&gt;  &lt;default&gt;)	;invisible    automatic common field

&lt;required field&gt; --&gt;
	|  &lt;field&gt;			;read-only    required field
	| (&lt;field&gt;)			;read-write   required field
	|  'field			;immutable    required field
	|  `field			;invisible    required field

&lt;optional field&gt; --&gt;
	|  (&lt;field&gt;  &lt;default&gt;)		;read-only    optional field
	| ((&lt;field&gt;) &lt;default&gt;)		;read-write   optional field
	| ('&lt;field&gt;  &lt;default&gt;)		;immutable    optional field
	| (`&lt;field&gt;  &lt;default&gt;)		;invisible    optional field

&lt;automatic field&gt; --&gt;
	|  (,&lt;field&gt;  &lt;default&gt;)	;read-only    automatic field
	| ((,&lt;field&gt;) &lt;default&gt;)	;read-write   automatic field
	| (',&lt;field&gt;  &lt;default&gt;)	;immutable    automatic field
	| (`,&lt;field&gt;  &lt;default&gt;)	;invisible    automatic field
	| (,,&lt;field&gt;  &lt;default&gt;)	;virtual      automatic field
</pre>
<p>The name of the first &lt;constructor&gt; is generated by prefixing "make-" to the
group name, or by prefixing "make-" and postfixing "-by-name" to the group
name.  And the name of the second &lt;constructor&gt; is generated by appending "/s"
to the name of the first &lt;constructor&gt;.
While the record lambda that is constructed by the former uses field indices
to identify the fields, the one constructed by the latter uses
symbols.  And the average time required to access a randomly chosen
field is more for the record lambda that is constructed by the latter
than for the one by the former.</p>

<p>The name of &lt;predicate&gt; is generated by adding a question mark ("?") to the
end of the group name.</p>

<p>The &lt;group&gt; and &lt;field&gt; must be identifiers.</p>

<p>Each &lt;default&gt; is an &lt;expression&gt; that is evaluated in
an environment in which the values of all the previous &lt;field&gt;s
are visible.</p>

<p>The define-record-lambda form is a definition and can appear anywhere any
other &lt;definition&gt; can appear.  Each time define-record-lambda form is
evaluated, a new group is created with distinct &lt;group&gt;, &lt;constructor&gt;, and
&lt;predicate&gt; procedures.</p>

<p>The &lt;group&gt; is bound to a procedure of one argument.  It has information on
its &lt;constructor&gt;s, &lt;predicate&gt;, and &lt;field&gt;s.</p>

<p>The &lt;constructor&gt; is bound to a procedure that takes at least as many
arguments as the number of &lt;required field&gt;s.  Whenever it is called, it
returns a record lambda of the &lt;group&gt;, namely a procedure.  Its first
argument must be a symbol of the same name as &lt;field&gt; or a field index whose
name is composed of the group name and field name. The record lambda becomes
an accessor procedure of each &lt;field&gt; in case of one argument and a mutator
procedure of each &lt;field&gt; in case of two arguments where the second argument
is a new field value.</p>

<p>The names of &lt;field&gt;s are used to access the &lt;field&gt;s.  So they must be
distinct.  The read-write fields can be modified, whereas any attempt to
modify the values of the read-only fields via mutators signals an error.</p>

<p>Note: The read-only fields are not immutable.
      Their values, for instance, can be modified by other fields whose values
      work like their mutators.</p>

<p>The &lt;required field&gt; is initialized to the first one of the remaining
arguments.  If there are no more remaining arguments, an error is signaled.</p>

The initialization of the &lt;optional field&gt;s is done by two types of
&lt;constructor&gt;s:

<dl>
  <dt>1. &lt;make-<em>group-name</em>&gt; constructor</dt>
   <dd>The initialization method of &lt;optional field&gt;s is the same as that of
&lt;required field&gt;s except that the field is bound to the &lt;default&gt; instead of
     signaling an error if there are no more remaining arguments.</dd>

   <dt>2. &lt;make-<em>group-name</em>-by-name&gt; constructor</dt>
   <dd>The name used at a call site for the corresponding &lt;optional field&gt; is a
symbol of the same name as the &lt;field&gt;.  The remaining arguments are
sequentially interpreted as a series of pairs, where the first member of each
pair is a field name and the second is the corresponding value.  If there is
no element for a particular field name, the field is initialized to the
     &lt;default&gt;.</dd></dl>

<p>The &lt;common field&gt;s are also &lt;automatic field&gt;s, and initialized to each
corresponding &lt;default&gt; that is evaluated at the time the define-record-lambda
form is evaluated, and the values are shared with all the record lambdas that
  are made by the constructors of the define-record-lambda form.</p>

<p>The other &lt;automatic field&gt;s except &lt;virtual field&gt;s are initialized to each
corresponding &lt;default&gt; that is evaluated at the time the record lambda is
made by a constructor.  Each &lt;default&gt; of &lt;virtual field&gt;s is evaluated each
  time when the field is accessed.</p>

<p>The &lt;invisible field&gt;s are externally nonexistent fields, that is, the fields
are invisible outside of the define-record-lambda form but accessible inside
of it.  On the contrary, the &lt;immutable field&gt;s and &lt;virtual field&gt;s are
internally nonexistent fields, that is, the fields are visible outside of the
  define-record-lambda form but inaccessible inside of it.</p>

<p>The &lt;predicate&gt; is a predicate procedure that returns #t for record lambdas
constructed by &lt;constructor&gt; or &lt;constructor&gt;s of a &lt;group&gt; and #f for
  everything else.</p>
<pre>
Examples

;; invisible &amp; immutable field example
(define-record-lambda stack
  (`stack '())					    ;invisible optional
  (',push (lambda (s) (set! stack (cons s stack)))) ;immutable automatic
  (,,pop (if (null? stack)			    ;virtual   automatic
	     (error &quot;null stack&quot; stack)
	     (let ((s (car stack)))
	       (set! stack (cdr stack))
	       s))))

(define st (make-stack))
(st stack-stack)	-&gt; error stack-stack: undefined
(st stack-pop)		-&gt; error null stack ()
(st stack-push 2)	-&gt; error invisible or immutable field
((st stack-push) &quot;rose&quot;)
((st stack-push) &quot;lily&quot;)
((st stack-push) &quot;sunflower&quot;)
(st stack-pop)		-&gt; &quot;sunflower&quot;
(st stack-pop)		-&gt; &quot;lily&quot;
(st stack-pop)		-&gt; &quot;rose&quot;
(st stack-pop)		-&gt; error null stack ()

(stack 'constructor)	-&gt; ((make-stack . make-stack-by-name)
			    (make-stack/s . make-stack-by-name/s))
(stack 'predicate)	-&gt; stack?
(stack 'field)		-&gt; ((total
			     (read-write-field ())
			     (read-only-field (push pop))
			     (invisible-field (stack)))
			    (types
			     (common-field ())
			     (required-field ())
			     (optional-field (stack))
			     (automatic-field (push pop))
			     (immutable-field (push))
			     (invisible-field (stack))
			     (virtual-field (pop))))
(stack 'index)		-&gt; ((stack-push . 0) (stack-pop . 1))


;; virtual field example
(let ()
  (define-record-lambda circle
    ((radius) 1)					   ;read-write optional
    (',area! (lambda (a) (set! radius (sqrt (/ a 3.14))))) ;immutable  automatic
    (,,area (* 3.14 radius radius)))	       	 	   ;virtual    automatic

  (list (let ((c (make-circle)))	;index
	  (list (c circle-area)
		(c circle-radius)
		(begin ((c circle-area!) (* 4 (c circle-area))) (c circle-area))
		(c circle-radius)
		(begin (c circle-radius 10) (c circle-area))
		(c circle-radius)))
	(let ((c (make-circle/s)))	;symbol
	  (list (c 'area)
		(c 'radius)
		(begin ((c 'area!) (* 4 (c 'area))) (c 'area))
		(c 'radius)
		(begin (c 'radius 10) (c 'area))
		(c 'radius)))))
-&gt; ((3.14 1 12.56 2.0 314.0 10) (3.14 1 12.56 2.0 314.0 10))


;; common field example
(let ()
  (define-record-lambda record
    (,@total-record 0)			;read-only automatic common
    (,@total-connect 0)			;read-only automatic common
    (,order-of-birth (begin		;read-only automatic
		       (set! total-record (+ 1 total-record))
		       total-record))
    (,individual-connect 0)		;read-only automatic
    (,,connect (begin			;virtual   automatic
		 (set! individual-connect (+ 1 individual-connect))
		 (set! total-connect (+ 1 total-connect))
		 'connect)))

  (let* ((record-1 (make-record/s))
	 (record-2 (make-record/s))
	 (record-3 (make-record/s))
	 (record-4 (make-record/s))
	 (record-5 (make-record/s)))
    (record-1 'connect) (record-1 'connect) (record-1 'connect)
    (record-1 'connect) (record-1 'connect) (record-2 'connect)
    (record-2 'connect) (record-2 'connect) (record-2 'connect)
    (record-3 'connect) (record-3 'connect) (record-3 'connect)
    (record-4 'connect) (record-4 'connect) (record-5 'connect)
    (map (lambda (o)
	   (list (list 'order-of-birth (o 'order-of-birth))
	   	 (list 'individual-connect (o 'individual-connect))
		 (list 'total-record (o 'total-record))
		 (list 'total-connect (o 'total-connect))))
	 (list record-1 record-2 record-3 record-4 record-5))))
-&gt;
(((order-of-birth 1) (individual-connect 5) (total-record 5) (total-connect 15))
 ((order-of-birth 2) (individual-connect 4) (total-record 5) (total-connect 15))
 ((order-of-birth 3) (individual-connect 3) (total-record 5) (total-connect 15))
 ((order-of-birth 4) (individual-connect 2) (total-record 5) (total-connect 15))
 ((order-of-birth 5) (individual-connect 1) (total-record 5) (total-connect 15)))

</pre>
<h1>Sample Implementation</h1>

<p>Sample implementations are provided based on both
<code>define-syntax</code> (syntax-rules with syntax-case or explicit
renaming macro) and <code>define-macro</code>.  They're available both
in the <a href="https://github.com/scheme-requests-for-implementation/srfi-184">Github
repo</a> and in <a href= "https://srfi.schemers.org/srfi-184/srfi-184.tgz">this
<code>.tgz</code> file</a>.</p>

<h1>References</h1>

<table class="references">
<tr><td>[R6RS]</td><td>Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton von Straaten: Revised(6) Report on the Algorithmic Language Scheme.<a class="eponymous" href="http://www.r6rs.org">http://www.r6rs.org</a></td></tr>
<tr><td>[SRFI 9]</td><td>Richard Kelsey: Defining Record Type.<a class="eponymous" href="http://srfi.schemers.org/srfi-9">http://srfi.schemers.org/srfi-9</a></td></tr>
<tr><td>[SRFI 100]</td><td>Joo ChurlSoo: Define-lambda-object.<a class="eponymous" href="http://srfi.schemers.org/srfi-100/">http://srfi.schemers.org/srfi-100/</a></td></tr></table>

<h1>Copyright</h1>

Copyright &copy; Joo ChurlSoo (2012).

<p>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

<p>
The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>