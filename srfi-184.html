<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>SRFI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>

<body>

<h1>Title</h1>

define-record-lambda

<h1>Author</h1>

Joo ChurlSoo

<h1>Changes</h1>
<pre>
Unlike the define-lambda-object:
1. The inheritance property has been removed because it was ineffective and
   superfluous.
2. The record lambda uses field indices or symbolized field names to identify
   fields according to the constructors.
3. The field sequence has been changed.

</pre>
<h1>Abstract</h1>

This one introduces a macro, DEFINE-RECORD-LAMBDA which defines a set of
procedures, that is, a group, constructors, and a predicate.  The constructors
also make a group of procedures, namely record lambdas, that have no explicit
field accessors and mutators.  They can have various kinds of fields, such as
common fields, required fields, optional fields, automatic fields, read-only
fields, read-write fields, invisible fields, immutable fields, and virtual
fields.

<h1>Rationale</h1>

A record lambda created by a constructor procedure is a procedure whose first
argument is a field index or symbolized field name that is used to identify
fields.  It depends on the constructor.  The record lambda plays the role of
the accessor and mutator of each field and makes the explicit or implicit
accessors and mutators unnecessary.  In addition, this reduces the role of the
predicate procedure.
<br>
This macro works not only as DEFINE-RECORD-TYPE with required fields but also
as DEFSTRUCT of Common Lisp with optional fields.  Each field except required
fields can be used as a procedure that changes the values of the other fields.
As a result, the record lambda itself has data and methods as well as their
accessors and mutators.

<h1>Specification</h1>
<pre>
(define-record-lambda &lt;group&gt; &lt;field spec&gt;)

&lt;field spec&gt; --&gt; &lt;common field&gt;* &lt;required field&gt;* &lt;optional field&gt;* &lt;automatic field&gt;*

&lt;common field&gt; --&gt;
	|  (,@&lt;field&gt;  &lt;default&gt;)	;read-only    automatic common field
	| ((,@&lt;field&gt;) &lt;default&gt;)	;read-write   automatic common field
	| (',@&lt;field&gt;  &lt;default&gt;)	;immutable    automatic common field
	| (`,@&lt;field&gt;  &lt;default&gt;)	;invisible    automatic common field

&lt;required field&gt; --&gt;
	|  &lt;field&gt;			;read-only    required field
	| (&lt;field&gt;)			;read-write   required field
	|  'field			;immutable    required field
	|  `field			;invisible    required field

&lt;optional field&gt; --&gt;
	|  (&lt;field&gt;  &lt;default&gt;)		;read-only    optional field
	| ((&lt;field&gt;) &lt;default&gt;)		;read-write   optional field
	| ('&lt;field&gt;  &lt;default&gt;)		;immutable    optional field
	| (`&lt;field&gt;  &lt;default&gt;)		;invisible    optional field

&lt;automatic field&gt; --&gt;
	|  (,&lt;field&gt;  &lt;default&gt;)	;read-only    automatic field
	| ((,&lt;field&gt;) &lt;default&gt;)	;read-write   automatic field
	| (',&lt;field&gt;  &lt;default&gt;)	;immutable    automatic field
	| (`,&lt;field&gt;  &lt;default&gt;)	;invisible    automatic field
	| (,,&lt;field&gt;  &lt;default&gt;)	;virtual      automatic field

The name of the first &lt;constructor&gt; is generated by prefixing `make-' to the
group name, or by prefixing `make-' and postfixing `-by-name' to the group
name.  And the name of the second &lt;constructor&gt; is generated by appending `/s'
to the name of the first &lt;constructor&gt;.
While the record lambda that is constructed by the former uses field indices
to identify the fields, the one by the latter uses symbols.  And the average
time required to access a randomly chosen field is more for the record lambda
that is constructed by the latter than for the one by the former.

The name of &lt;predicate&gt; is generated by adding a question mark (`?') to the
end of the group name.

The &lt;group&gt; and &lt;field&gt; must be identifiers.

Each &lt;default&gt; is an &lt;expression&gt; that is evaluated in an environment that the
values of all the previous &lt;field&gt;s are visible.

The define-record-lambda form is a definition and can appear anywhere any
other &lt;definition&gt; can appear.  Each time define-record-lambda form is
evaluated, a new group is created with distinct &lt;group&gt;, &lt;constructor&gt;, and
&lt;predicate&gt; procedures.

The &lt;group&gt; is bound to a procedure of one argument.  It has information on
its &lt;constructor&gt;s, &lt;predicate&gt;, and &lt;field&gt;s.

The &lt;constructor&gt; is bound to a procedure that takes at least as many
arguments as the number of &lt;required field&gt;s.  Whenever it is called, it
returns a record lambda of the &lt;group&gt;, namely a procedure.  Its first
argument must be a symbol of the same name as &lt;field&gt; or a field index whose
name is composed of the group name and field name. The record lambda becomes
an accessor procedure of each &lt;field&gt; in case of one argument and a mutator
procedure of each &lt;field&gt; in case of two arguments where the second argument
is a new field value.

The names of &lt;field&gt;s are used to access the &lt;field&gt;s.  So they must be
distinct.  The read-write fields can be modified, whereas any attempt to
modify the values of the read-only fields via mutators signals an error.
Note: The read-only fields are not immutable.
      Their values, for instance, can be modified by other fields whose values
      work like their mutators.

The &lt;required field&gt; is initialized to the first one of the remaining
arguments.  If there are no more remaining arguments, an error is signaled.

The initialization of the &lt;optional field&gt;s is done by two types of
&lt;constructor&gt;s:
1. &lt;make-`group-name'&gt; constructor
   The initialization method of &lt;optional field&gt;s is the same as that of
&lt;required field&gt;s except that the field is bound to the &lt;default&gt; instead of
signaling an error if there are no more remaining arguments.

2. &lt;make-`group-name'-by-name&gt; constructor
   The name used at a call site for the corresponding &lt;optional field&gt; is a
symbol of the same name as the &lt;field&gt;.  The remaining arguments are
sequentially interpreted as a series of pairs, where the first member of each
pair is a field name and the second is the corresponding value.  If there is
no element for a particular field name, the field is initialized to the
&lt;default&gt;.

The &lt;common field&gt;s are also &lt;automatic field&gt;s, and initialized to each
corresponding &lt;default&gt; that is evaluated at the time the define-record-lambda
form is evaluated, and the values are shared with all the record lambdas that
are maded by the constructors of the define-record-lambda form.
The other &lt;automatic field&gt;s except &lt;virtual field&gt;s are initialized to each
corresponding &lt;default&gt; that is evaluated at the time the record lambda is
made by a constructor.  Each &lt;default&gt; of &lt;virtual field&gt;s is evaluated each
time when the field is accessed.

The &lt;invisible field&gt;s are externally nonexistent fields, that is, the fields
are invisible outside of the define-record-lambda form but accessible inside
of it.  On the contrary, the &lt;immutable field&gt;s and &lt;virtual field&gt;s are
internally nonexistent fields, that is, the fields are visible outside of the
define-record-lambda form but inaccessible inside of it.

The &lt;predicate&gt; is a predicate procedure that returns #t for record lambdas
constructed by &lt;constructor&gt; or &lt;constructor&gt;s of a &lt;group&gt; and #f for
everything else.


Examples

;; invisible &amp; immutable field example
(define-record-lambda stack
  (`stack '())					    ;invisible optional
  (',push (lambda (s) (set! stack (cons s stack)))) ;immutable automatic
  (,,pop (if (null? stack)			    ;virtual   automatic
	     (error &quot;null stack&quot; stack)
	     (let ((s (car stack)))
	       (set! stack (cdr stack)) s))))

(define st (make-stack))
(st stack-stack)	-&gt; error stack-stack: undefined
(st stack-pop)		-&gt; error null stack ()
(st stack-push 2)	-&gt; error invisible or immutable field
((st stack-push) &quot;rose&quot;)
((st stack-push) &quot;lily&quot;)
((st stack-push) &quot;sunflower&quot;)
(st stack-pop)		-&gt; &quot;sunflower&quot;
(st stack-pop)		-&gt; &quot;lily&quot;
(st stack-pop)		-&gt; &quot;rose&quot;
(st stack-pop)		-&gt; error null stack ()

(stack 'constructor)	-&gt; ((make-stack . make-stack-by-name)
			    (make-stack/s . make-stack-by-name/s))
(stack 'predicate)	-&gt; stack?
(stack 'field)		-&gt; ((total
			     (read-write-field ())
			     (read-only-field (push pop))
			     (invisible-field (stack)))
			    (types
			     (common-field ())
			     (required-field ())
			     (optional-field (stack))
			     (automatic-field (push pop))
			     (immutable-field (push))
			     (invisible-field (stack))
			     (virtual-field (pop))))
(stack 'index)		-&gt; ((stack-push . 0) (stack-pop . 1))


;; virtual field example
(let ()
  (define-record-lambda circle
    ((radius) 1)					   ;read-write optional
    (',area! (lambda (a) (set! radius (sqrt (/ a 3.14))))) ;immutable  automatic
    (,,area (* 3.14 radius radius)))	       	 	   ;virtual    automatic

  (list (let ((c (make-circle)))	;index
	  (list (c circle-area)
		(c circle-radius)
		(begin ((c circle-area!) (* 4 (c circle-area))) (c circle-area))
		(c circle-radius)
		(begin (c circle-radius 10) (c circle-area))
		(c circle-radius)))
	(let ((c (make-circle/s)))	;symbol
	  (list (c 'area)
		(c 'radius)
		(begin ((c 'area!) (* 4 (c 'area))) (c 'area))
		(c 'radius)
		(begin (c 'radius 10) (c 'area))
		(c 'radius)))))
-&gt; ((3.14 1 12.56 2.0 314.0 10) (3.14 1 12.56 2.0 314.0 10))


;; common field example
(let ()
  (define-record-lambda record
    (,@total-record 0)			;read-only automatic common
    (,@total-connect 0)			;read-only automatic common
    (,order-of-birth (begin		;read-only automatic
		       (set! total-record (+ 1 total-record))
		       total-record))
    (,individual-connect 0)		;read-only automatic
    (,,connect (begin			;virtual   automatic
		 (set! individual-connect (+ 1 individual-connect))
		 (set! total-connect (+ 1 total-connect))
		 'connect)))

  (let* ((record-1 (make-record/s))
	 (record-2 (make-record/s))
	 (record-3 (make-record/s))
	 (record-4 (make-record/s))
	 (record-5 (make-record/s)))
    (record-1 'connect) (record-1 'connect) (record-1 'connect)
    (record-1 'connect) (record-1 'connect) (record-2 'connect)
    (record-2 'connect) (record-2 'connect) (record-2 'connect)
    (record-3 'connect) (record-3 'connect) (record-3 'connect)
    (record-4 'connect) (record-4 'connect) (record-5 'connect)
    (map (lambda (o)
	   (list (list 'order-of-birth (o 'order-of-birth))
	   	 (list 'individual-connect (o 'individual-connect))
		 (list 'total-record (o 'total-record))
		 (list 'total-connect (o 'total-connect))))
	 (list record-1 record-2 record-3 record-4 record-5))))
-&gt;
(((order-of-birth 1) (individual-connect 5) (total-record 5) (total-connect 15))
 ((order-of-birth 2) (individual-connect 4) (total-record 5) (total-connect 15))
 ((order-of-birth 3) (individual-connect 3) (total-record 5) (total-connect 15))
 ((order-of-birth 4) (individual-connect 2) (total-record 5) (total-connect 15))
 ((order-of-birth 5) (individual-connect 1) (total-record 5) (total-connect 15)))

</pre>
<h1>Reference Implementation</h1>
<pre>
The implementation below is written in define-syntax (syntax-rules with
syntax-case or explicit renaming macro), and define-macro.

;;; define-record-lambda --- define-syntax

(define err-str &quot;define-record-lambda: invisible or immutable field&quot;)
(define-syntax unquote-get
  (syntax-rules ()
    ((unquote-get symbol ((n0 v0) n1 ...))
     (if (eq? symbol 'n0)
	 v0
	 (unquote-get symbol (n1 ...))))
    ((unquote-get symbol (n0 n1 ...))
     (if (eq? symbol 'n0)
	 n0
	 (unquote-get symbol (n1 ...))))
    ((unquote-get symbol ())
     (error err-str symbol))))

(define-syntax unquote-set!
  (syntax-rules ()
    ((unquote-set! symbol new-val (n0 n1 ...))
     (if (eq? symbol 'n0)
	 (set! n0 new-val)
	 (unquote-set! symbol new-val (n1 ...))))
    ((unquote-set! symbol new-val ())
     (error err-str symbol))))

(define (check-duplicate ls err-str)
  (cond ((null? ls) #f)
	((memq (car ls) (cdr ls)) (error err-str (car ls)))
	(else (check-duplicate (cdr ls) err-str))))

(define (number-alist ls)
  (let loop ((ls ls) (n 0))
    (if (null? ls)
	'()
	(cons (cons (car ls) n) (loop (cdr ls) (+ 1 n))))))

(define-syntax define-lambda
  (syntax-rules ()
    ((define-lambda name unique-name make-record make-record-by-name make-record/s make-record-by-name/s pred-record (name-fm ...) (name-fi ...) (fm ...) ((fi fd) ...) ((c ct cv) ...) ((r rt) ...) ((o ot ov) ...) ((a at av) ...) (h ...) (i ...) (v ...))
     (begin
       ;; A vector or list can be used instead of unquote-get &amp; unquote-set!.
       ;; cf. (eval-variant expression implementation-specific-namespace)

       (define name-alist-a (number-alist '(name-fm ... name-fi ...)))
       (define name-alist-m (number-alist '(name-fm ...)))
       (define num-a (length name-alist-a))
       (define num-m (length name-alist-m))
       (define name-fi (cdr (assq 'name-fi name-alist-a))) ...
       (define name-fm (cdr (assq 'name-fm name-alist-m))) ...

       ;; You can choose a suitable constructor.
       ;; 1. number
       (define maker
	 (let* ((ct cv) ...)
	   (cons (lambda (rt ... . rest)
		   (alet* ((opt rest (ot ov) ...)
			   (at av) ...)
		     (define unique-name
		       (if (and (null? '((c ct cv) ...)) (null? '((o ot ov) ...)) (null? '((a at av) ...)) (null? '(v ...)))
			   (let ((v-all (vector fm ... fd ...)))
			     (cond
			      ((null? '(fi ...))
			       ;; (case-lambda
			       ;; 	((arg) (vector-ref v-all arg))
			       ;; 	((arg val) (vector-set! v-all arg val))))
			       (lambda (arg . args)
				 (if (null? args)
				     (vector-ref v-all arg)
				     (vector-set! v-all arg (car args)))))
			      ((null? '(fm ...))
			       (lambda (arg) (vector-ref v-all arg)))
			      (else
			       ;; (case-lambda
			       ;; 	((arg) (vector-ref v-all arg))
			       ;; 	((arg val) (if (&lt; arg num-m)
			       ;; 		       (vector-set! v-all arg val)
			       ;; 		       (error err-str arg)))))))
			       (lambda (arg . args)
				 (if (null? args)
				     (vector-ref v-all arg)
				     (if (&lt; arg num-m)
					 (vector-set! v-all arg (car args))
					 (error err-str arg)))))))
			   (let ((v-all (vector (lambda (x) (if (eq? 'unique-name x) fm (set! fm x))) ... (lambda (x) (if (eq? 'unique-name x) fd (error err-str))) ...)))
			     ;; (case-lambda
			     ;;  ((arg) ((vector-ref v-all arg) 'unique-name))
			     ;;  ((arg val) ((vector-ref v-all arg) val))))))
			     (lambda (arg . args)
			       (if (null? args)
				   ((vector-ref v-all arg) 'unique-name)
				   ((vector-ref v-all arg) (car args)))))))
		     unique-name))
		 (lambda (rt ... . rest)
		   (alet* ((opt rest (('ot 'o) ov) ...)
			   (at av) ...)
		     (define unique-name
		       (if (and (null? '((c ct cv) ...)) (null? '((o ot ov) ...)) (null? '((a at av) ...)) (null? '(v ...)))
			   (let ((v-all (vector fm ... fd ...)))
			     (cond
			      ((null? '(fi ...))
			       ;; (case-lambda
			       ;; 	((arg) (vector-ref v-all arg))
			       ;; 	((arg val) (vector-set! v-all arg val))))
			       (lambda (arg . args)
				 (if (null? args)
				     (vector-ref v-all arg)
				     (vector-set! v-all arg (car args)))))
			      ((null? '(fm ...))
			       (lambda (arg) (vector-ref v-all arg)))
			      (else
			       ;; (case-lambda
			       ;; 	((arg) (vector-ref v-all arg))
			       ;; 	((arg val) (if (&lt; arg num-m)
			       ;; 		       (vector-set! v-all arg val)
			       ;; 		       (error err-str arg)))))))
			       (lambda (arg . args)
				 (if (null? args)
				     (vector-ref v-all arg)
				     (if (&lt; arg num-m)
					 (vector-set! v-all arg (car args))
					 (error err-str arg)))))))
			   (let ((v-all (vector (lambda (x) (if (eq? 'unique-name x) fm (set! fm x))) ... (lambda (x) (if (eq? 'unique-name x) fd (error err-str))) ...)))
			     ;; (case-lambda
			     ;;  ((arg) ((vector-ref v-all arg) 'unique-name))
			     ;;  ((arg val) ((vector-ref v-all arg) val))))))
			     (lambda (arg . args)
			       (if (null? args)
				   ((vector-ref v-all arg) 'unique-name)
				   ((vector-ref v-all arg) (car args)))))))
		     unique-name)))))
       (define make-record (car maker))
       (define make-record-by-name (cdr maker))

       ;; 2. symbol
       (define maker/s
	 (let* ((ct cv) ...)
	   (cons (lambda (rt ... . rest)
		   (alet* ((opt rest (ot ov) ...)
			   (at av) ...)
		     (define unique-name
		       ;; (case-lambda
		       ;; 	((arg) (unquote-get arg ((fm fm) ... (fi fd) ...)))
		       ;; 	((arg val) (unquote-set! arg val (fm ...)))))
		       (lambda (arg . args)
			 (if (null? args)
			     (unquote-get arg ((fm fm) ... (fi fd) ...))
			     (unquote-set! arg (car args) (fm ...)))))
		     unique-name))
		 (lambda (rt ... . rest)
		   (alet* ((opt rest (('ot 'o) ov) ...)
			   (at av) ...)
		     (define unique-name
		       ;; (case-lambda
		       ;; 	((arg) (unquote-get arg ((fm fm) ... (fi fd) ...)))
		       ;; 	((arg val) (unquote-set! arg val (fm ...)))))
		       (lambda (arg . args)
			 (if (null? args)
			     (unquote-get arg ((fm fm) ... (fi fd) ...))
			     (unquote-set! arg (car args) (fm ...)))))
		     unique-name)))))
       (define make-record/s (car maker/s))
       (define make-record-by-name/s (cdr maker/s))

       ;; The predicate procedure is implementation dependant.
       ;; A procedure such as `object-name' is necessary for this to work.
       ;; In the following explicit-renaming or syntax-case macro, the `gensym'
       ;; procedure is necessary.

       (define (pred-record record)	;racket
       	 (eq? 'unique-name (object-name record)))

       (define name
	 (let ((constructor `(,maker ,maker/s))
	       (predicate pred-record)
	       (field `((total (read-write-field (fm ...))
			       (read-only-field (fi ...))
			       (invisible-field ,(map car '(h ...))))
			(types (common-field (c ...))
			       (required-field (r ...))
			       (optional-field (o ...))
			       (automatic-field (a ... ,@(map car '(v ...))))
			       (immutable-field ,(map car '(i ...)))
			       (invisible-field ,(map car '(h ...)))
			       (virtual-field ,(map car '(v ...))))))
	       (index name-alist-a))
	   (check-duplicate '(fm ... fi ... ,@(map car '(h ...)))
			    &quot;define-record-lambda: duplicated field&quot;)
	   (lambda (sym)
	     (unquote-get sym (constructor predicate field index)))))))))

;; conventional-lisp macro
;; (define-macro (define-identifier name fm fi c r o a h i v)
;;   (let ((nm-str (symbol-&gt;string name)))
;;     (let ((unique-name (gensym))
;; 	  (make-record (string-&gt;symbol (string-append &quot;make-&quot; nm-str)))
;; 	  (make-record-by-name (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name&quot;)))
;; 	  (make-record/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;/s&quot;)))
;; 	  (make-record-by-name/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name/s&quot;)))
;; 	  (pred-record (string-&gt;symbol (string-append nm-str &quot;?&quot;)))
;; 	  (name-fm (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) fm))
;; 	  (name-fi (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) (map car fi))))
;;       `(define-lambda ,name ,unique-name ,make-record ,make-record-by-name ,make-record/s ,make-record-by-name/s ,pred-record ,name-fm ,name-fi ,fm ,fi ,c ,r ,o ,a ,h ,i ,v))))

;; explicit renaming macro
;; (define-syntax define-identifier
;;   (er-macro-transformer
;;    (lambda (form rename compare)
;;      (let* ((name (cadr form))
;; 	    (fields (cddr form))
;; 	    (nm-str (symbol-&gt;string name)))
;;        (let ((unique-name (gensym))
;; 	     (make-record (string-&gt;symbol (string-append &quot;make-&quot; nm-str)))
;; 	     (make-record-by-name (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name&quot;)))
;; 	     (make-record/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;/s&quot;)))
;; 	     (make-record-by-name/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name/s&quot;)))
;; 	     (pred-record (string-&gt;symbol (string-append nm-str &quot;?&quot;)))
;; 	     (name-fm (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) (car fields)))
;; 	     (name-fi (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) (map car (cadr fields))))
;; 	     (%define-lambda (rename 'define-lambda)))
;; 	 `(,%define-lambda ,name ,unique-name ,make-record ,make-record-by-name ,make-record/s ,make-record-by-name/s ,pred-record ,name-fm ,name-fi ,@fields))))))

;; syntax-case macro
(define-syntax define-identifier
  (lambda (x)
    (syntax-case x ()
      ((_ nm fm fi c r o a h i v)
       (let* ((name (syntax-&gt;datum #'nm))
	      (fmm (syntax-&gt;datum #'fm))
	      (fii (syntax-&gt;datum #'fi))
	      (nm-str (symbol-&gt;string name)))
	 (let ((unique-nm (gensym))
	       (make-obj (string-&gt;symbol (string-append &quot;make-&quot; nm-str)))
	       (make-obj-by-name (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name&quot;)))
	       (make-obj/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;/s&quot;)))
	       (make-obj-by-name/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name/s&quot;)))
	       (pred-obj (string-&gt;symbol (string-append nm-str &quot;?&quot;)))
	       (n-fm (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) fmm))
	       (n-fi (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) (map car fii))))
	   (with-syntax
	    ((unique-name (datum-&gt;syntax #'nm unique-nm))
	     (make-record (datum-&gt;syntax #'nm make-obj))
	     (make-record-by-name (datum-&gt;syntax #'nm make-obj-by-name))
	     (make-record/s (datum-&gt;syntax #'nm make-obj/s))
	     (make-record-by-name/s (datum-&gt;syntax #'nm make-obj-by-name/s))
	     (pred-record (datum-&gt;syntax #'nm pred-obj))
	     (name-fm (datum-&gt;syntax #'nm n-fm))
	     (name-fi (datum-&gt;syntax #'nm n-fi)))
	    #'(define-lambda nm unique-name make-record make-record-by-name make-record/s make-record-by-name/s pred-record name-fm name-fi fm fi c r o a h i v))))))))

(define-syntax define-field
  (syntax-rules (quote quasiquote unquote unquote-splicing)
    ((define-field nm ((`,@n d) . e) fm fi (c ...) () () () (h ...) i ())
     (define-field nm e fm fi (c ... (n n d)) () () () (h ... (n d)) i ()))
    ((define-field nm ((',@n d) . e) fm (fi ...) (c ...) () () () h (i ...) ())
     (define-field nm e fm (fi ... (n t)) (c ... (n t d)) () () () h (i ... (n d)) ()))
    ((define-field nm ((`,n d) . e) fm fi c r o (a ...) (h ...) i v)
     (define-field nm e fm fi c r o (a ... (n n d)) (h ... (n d)) i v))
    ((define-field nm ((',n d) . e) fm (fi ...) c r o (a ...) h (i ...) v)
     (define-field nm e fm (fi ... (n t)) c r o (a ... (n t d)) h (i ... (n d)) v))
    ((define-field nm ((,,n d) . e) fm (fi ...) c r o a h i (v ...))
     (define-field nm e fm (fi ... (n d)) c r o a h i (v ... (n d))))
    ((define-field nm (((,@n) d) . e) (fm ...) fi (c ...) () () () h i ())
     (define-field nm e (fm ... n) fi (c ... (n n d)) () () () h i ()))
    ((define-field nm (((,n) d) . e) (fm ...) fi c r o (a ...) h i v)
     (define-field nm e (fm ... n) fi c r o (a ... (n n d)) h i v))
    ((define-field nm ((,@n d) . e) fm (fi ...) (c ...) () () () h i ())
     (define-field nm e fm (fi ... (n n)) (c ... (n n d)) () () () h i ()))
    ((define-field nm ((,n d) . e) fm (fi ...) c r o (a ...) h i v)
     (define-field nm e fm (fi ... (n n)) c r o (a ... (n n d)) h i v))
    ((define-field nm ((`n d) . e) fm fi c r (o ...) () (h ...) i ())
     (define-field nm e fm fi c r (o ... (n n d)) () (h ... (n d)) i ()))
    ((define-field nm (('n d) . e) fm (fi ...) c r (o ...) () h (i ...) ())
     (define-field nm e fm (fi ... (n t)) c r (o ... (n t d)) () h (i ... (n d)) ()))
    ((define-field nm (((n) d) . e) (fm ...) fi c r (o ...) () h i ())
     (define-field nm e (fm ... n) fi c r (o ... (n n d)) () h i ()))

    ((define-field nm (`n . e) fm fi c (r ...) () () (h ...) i ())
     (define-field nm e fm fi c (r ... (n n)) () () (h ... (n n)) i ()))
    ((define-field nm ('n . e) fm (fi ...) c (r ...) () () h (i ...) ())
     (define-field nm e fm (fi ... (n t)) c (r ... (n t)) () () h (i ... (n n)) ()))

    ((define-field nm ((n d) . e) fm (fi ...) c r (o ...) () h i ())
     (define-field nm e fm (fi ... (n n)) c r (o ... (n n d)) () h i ()))
    ((define-field nm ((n) . e) (fm ...) fi c (r ...) () () h i ())
     (define-field nm e (fm ... n) fi c (r ... (n n)) () () h i ()))
    ((define-field nm (n . e) fm (fi ...) c (r ...) () () h i ())
     (define-field nm e fm (fi ... (n n)) c (r ... (n n)) () () h i ()))
    ((define-field nm () fm fi c r o a h i v)
     (define-identifier nm fm fi c r o a h i v))))

(define-syntax define-record-lambda
  (syntax-rules ()
    ((define-record-lambda name . f)
     (define-field name f () () () () () () () () ()))))

;;; eof

;;; define-record-lambda --- define-macro

(define err-str &quot;define-record-lambda: invisible or immutable field&quot;)
(define-macro (unquote-get symbol args)
  (define (lp args)
    (if (null? args)
	`(error err-str ,symbol)
	(let ((arg (car args)))
	  (if (pair? arg)
	      `(if (eq? ,symbol ',(car arg))
		   ,(cadr arg)
		   ,(lp (cdr args)))
	      `(if (eq? ,symbol ',arg)
		   ,arg
		   ,(lp (cdr args)))))))
  (lp args))
;; (define-macro (unquote-get symbol args)
;;   (if (null? args)
;;       `(error err-str ,symbol)
;;       (let ((arg (car args)))
;; 	(if (pair? arg)
;; 	    `(if (eq? ,symbol ',(car arg))
;; 		 ,(cadr arg)
;; 		 (unquote-get ,symbol ,(cdr args)))
;; 	    `(if (eq? ,symbol ',arg)
;; 		 ,arg
;; 		 (unquote-get ,symbol ,(cdr args)))))))

(define-macro (unquote-set! symbol new-val args)
  (define (lp args)
    (if (null? args)
	`(error err-str ,symbol)
	(let ((arg (car args)))
	  `(if (eq? ,symbol ',arg)
	       (set! ,arg ,new-val)
	       ,(lp (cdr args))))))
  (lp args))

(define (check-duplicate ls err-str)
  (cond ((null? ls) #f)
	((memq (car ls) (cdr ls)) (error err-str (car ls)))
	(else (check-duplicate (cdr ls) err-str))))

(define (number-alist ls)
  (let loop ((ls ls) (n 0))
    (if (null? ls)
	'()
	(cons (cons (car ls) n) (loop (cdr ls) (+ 1 n))))))

(define-macro (define-lambda name fm fi c r o a h i v)
  (let ((arg (gensym))
	;; (val (gensym))
	(args (gensym))
	(rest (gensym))
	(maker (gensym))
	(maker/s (gensym))
	(v-all (gensym))
	(name-alist-m (gensym))
	(name-alist-a (gensym))
	(num-m (gensym))
	(num-a (gensym))
	(safe (gensym))
	(unique-name (gensym))
	(nm-str (symbol-&gt;string name)))
    (let ((make-record (string-&gt;symbol (string-append &quot;make-&quot; nm-str)))
	  (make-record-by-name (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name&quot;)))
	  (make-record/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;/s&quot;)))
	  (make-record-by-name/s (string-&gt;symbol (string-append &quot;make-&quot; nm-str &quot;-by-name/s&quot;)))
	  (pred-record (string-&gt;symbol (string-append nm-str &quot;?&quot;)))
	  (name-fm (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) fm))
	  (name-fi (map (lambda (x) (string-&gt;symbol (string-append nm-str &quot;-&quot; (symbol-&gt;string x)))) (map car fi))))
      `(begin
	 ;; A vector or list can be used instead of unquote-get &amp; unquote-set!.
	 ;; cf. (eval-variant expression implementation-specific-namespace)

	 (define ,name-alist-a (number-alist ',(append name-fm name-fi)))
	 (define ,name-alist-m (number-alist ',name-fm))
	 (define ,num-a (length ,name-alist-a))
	 (define ,num-m (length ,name-alist-m))
	 ,@(map (lambda (f) `(define ,f (cdr (assq ',f ,name-alist-a)))) name-fi)
	 ,@(map (lambda (f) `(define ,f (cdr (assq ',f ,name-alist-m)))) name-fm)

	 ;; You can choose a suitable constructor.
	 ;; 1. number
	 (define ,maker
	   (let* ,(map cdr c)
	     (cons (lambda (,@(map cadr r) . ,rest)
		     (alet* ((opt ,rest ,@(map cdr o))
			     ,@(map cdr a))
		       (define ,unique-name
			 (if (and (null? ',c) (null? ',o) (null? ',a) (null? ',v))
			     (let ((,v-all (vector ,@fm ,@(map cadr fi))))
			       (cond
				((null? ',fi)
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (vector-set! ,v-all ,arg ,val))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (vector-set! ,v-all ,arg (car ,args)))))
				((null? ',fm)
				 (lambda (,arg) (vector-ref ,v-all ,arg)))
				(else
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (if (&lt; ,arg ,num-m)
				 ;; 		   (vector-set! ,v-all ,arg ,val)
				 ;; 		   (error err-str ,arg)))))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (if (&lt; ,arg ,num-m)
					   (vector-set! ,v-all ,arg (car ,args))
					   (error err-str ,arg)))))))
			     (let ((,v-all (vector ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (set! ,f ,safe)))) fm) ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (error ,err-str)))) (map cadr fi)))))
			       ;; (case-lambda
			       ;; 	((,arg) ((vector-ref ,v-all ,arg) ',unique-name))
			       ;; 	((,arg ,val) ((vector-ref ,v-all ,arg) ,val))))))
			       (lambda (,arg . ,args)
				 (if (null? ,args)
				     ((vector-ref ,v-all ,arg) ',unique-name)
				     ((vector-ref ,v-all ,arg) (car ,args)))))))
		       ,unique-name))
		   (lambda (,@(map cadr r) . ,rest)
		     (alet* ((opt ,rest ,@(map (lambda (ntv) `((',(cadr ntv) ',(car ntv)) ,(caddr ntv))) o))
			     ,@(map cdr a))
		       (define ,unique-name
			 (if (and (null? ',c) (null? ',o) (null? ',a) (null? ',v))
			     (let ((,v-all (vector ,@fm ,@(map cadr fi))))
			       (cond
				((null? ',fi)
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (vector-set! ,v-all ,arg ,val))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (vector-set! ,v-all ,arg (car ,args)))))
				((null? ',fm)
				 (lambda (,arg) (vector-ref ,v-all ,arg)))
				(else
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (if (&lt; ,arg ,num-m)
				 ;; 		   (vector-set! ,v-all ,arg ,val)
				 ;; 		   (error err-str ,arg)))))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (if (&lt; ,arg ,num-m)
					   (vector-set! ,v-all ,arg (car ,args))
					   (error err-str ,arg)))))))
			     (let ((,v-all (vector ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (set! ,f ,safe)))) fm) ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (error ,err-str)))) (map cadr fi)))))
			       ;; (case-lambda
			       ;; 	((,arg) ((vector-ref ,v-all ,arg) ',unique-name))
			       ;; 	((,arg ,val) ((vector-ref ,v-all ,arg) ,val))))))
			       (lambda (,arg . ,args)
				 (if (null? ,args)
				     ((vector-ref ,v-all ,arg) ',unique-name)
				     ((vector-ref ,v-all ,arg) (car ,args)))))))
		       ,unique-name)))))
	 (define ,make-record (car ,maker))
	 (define ,make-record-by-name (cdr ,maker))

	 ;; 2. symbol
	 (define ,maker/s
	   (let* ,(map cdr c)
	     (cons (lambda (,@(map cadr r) . ,rest)
		     (alet* ((opt ,rest ,@(map cdr o))
			     ,@(map cdr a))
		       (define ,unique-name
			 ;; (case-lambda
		       	 ;;  ((,arg) (unquote-get ,arg ,(append (map list fm fm) fi)))
		       	 ;;  ((,arg ,val) (unquote-set! ,arg ,val ,fm))))
			 (lambda (,arg . ,args)
			   (if (null? ,args)
			       (unquote-get ,arg ,(append (map list fm fm) fi))
			       (unquote-set! ,arg (car ,args) ,fm))))
		       ,unique-name))
		   (lambda (,@(map cadr r) . ,rest)
		     (alet* ((opt ,rest ,@(map (lambda (ntv) `((',(cadr ntv) ',(car ntv)) ,(caddr ntv))) o))
			     ,@(map cdr a))
		       (define ,unique-name
			 ;; (case-lambda
		       	 ;;  ((,arg) (unquote-get ,arg ,(append (map list fm fm) fi)))
		       	 ;;  ((,arg ,val) (unquote-set! ,arg ,val ,fm))))
			 (lambda (,arg . ,args)
			   (if (null? ,args)
			       (unquote-get ,arg ,(append (map list fm fm) fi))
			       (unquote-set! ,arg (car ,args) ,fm))))
		       ,unique-name)))))
	 (define ,make-record/s (car ,maker/s))
	 (define ,make-record-by-name/s (cdr ,maker/s))

	 ;; The predicate procedure is implementation dependant.
	 ;; A procedure such as `object-name' is necessary for this to work.
	 (define (,pred-record record)	;racket
	   (eq? ',unique-name (object-name record)))

	 (define ,name
	   (let ((constructor `(,,maker ,,maker/s))
		 (predicate ,pred-record)
		 (field `((total (read-write-field ,',fm)
				 (read-only-field ,',(map car fi))
				 (invisible-field ,',(map car h)))
			  (types (common-field ,',(map car c))
				 (required-field ,',(map car r))
				 (optional-field ,',(map car o))
				 (automatic-field ,',(append (map car a) (map car v)))
				 (immutable-field ,',(map car i))
				 (invisible-field ,',(map car h))
				 (virtual-field ,',(map car v)))))
		 (index ,name-alist-a))
	     (check-duplicate ',(append fm (map car fi) (map car h))
			      &quot;define-record-lambda: duplicated field&quot;)
	     (lambda (sym)
	       (unquote-get sym (constructor predicate field index)))))))))

(define-macro (define-record-lambda name . field)
  (define (field-sort field fm fi c r o a h i v)
    (if (null? field)
	`(define-lambda ,name ,fm ,fi ,c ,r ,o ,a ,h ,i ,v)
	(let ((vars (car field)))
	  (if (symbol? vars)		;r
	      (if (and (null? o) (null? a) (null? v))
		  (field-sort (cdr field)
			      fm (append fi (list (list vars vars)))
			      c (append r (list (list vars vars))) o a h i v)
		  (error &quot;define-record-lambda: required-field should precede optional-field and automatic-field&quot; vars))
	      (let ((var (car vars)))
		(if (symbol? var)
		    (if (null? (cdr vars)) ;(r)
			(if (and (null? o) (null? a) (null? v))
			    (field-sort (cdr field)
					(append fm vars) fi
					c (append r (list (list (car vars) (car vars)))) o a h i v)
			    (error &quot;define-record-lambda: required-field should precede optional-field and automatic-field&quot; var))
			(if (null? (cddr vars)) ;(var val)
			    (if (and (null? a) (null? v))
				(cond
				 ((eq? 'quasiquote var)
				  (if (null? o)	;`r
				      (let ((val (cadr vars)))
					(field-sort (cdr field)
						    fm fi
						    c (append r (list (list val val))) o a (append h (list (list val val))) i v))
				      (error &quot;define-record-lambda: required-field should precede optional-field&quot; var)))
				 ((eq? 'quote var)
				  (if (null? o)	;'r
				      (let ((t (gensym)) (val (cadr vars)))
					(field-sort (cdr field)
						    fm (append fi (list (list val t)))
						    c (append r (list (list val t))) o a h (append i (list (list val val))) v))
				      (error &quot;define-record-lambda: required-field should precede optional-field&quot; var)))
				 (else	;(o val)
				  (field-sort (cdr field)
					      fm (append fi (list (list var var)))
					      c r (append o (list (cons var vars))) a h i v)))
				(error &quot;define-record-lambda: required-field and optional-field should precede automatic-field&quot; var))
			    (error &quot;define-record-lambda: incorrect syntax&quot; vars)))
		    (if (and (pair? (cdr vars)) (null? (cddr vars)))
			(let ((b (car var)))
			  (if (symbol? b)
			      (if (null? (cdr var)) ;((o) val)
				  (if (and (null? a) (null? v))
				      (field-sort (cdr field)
						  (append fm var) fi
						  c r (append o (list (list b b (cadr vars)))) a h i v)
				      (error &quot;define-record-lambda: optional-field should precede automatic-field&quot; b))
				  (if (null? (cddr var))
				      (let ((d (cadr var)))
					(cond
					 ((symbol? d)
					  (cond
					   ((eq? 'unquote b) ;(,a val)
					    (field-sort (cdr field)
							fm (append fi (list (list d d)))
							c r o (append a (list (list d d (cadr vars)))) h i v))
					   ((eq? 'quasiquote b) ;(`o val)
					    (if (and (null? a) (null? v))
						(field-sort (cdr field)
							    fm fi
							    c r (append o (list (list d d (cadr vars)))) a (append h (list (cons d (cdr vars)))) i v)
						(error &quot;define-record-lambda: optional-field should precede automatic-field&quot; d)))
					   ((eq? 'quote b) ;('o val)
					    (if (and (null? a) (null? v))
						(let ((t (gensym)))
						  (field-sort (cdr field)
							      fm (append fi (list (list d t)))
							      c r (append o (list (list d t (cadr vars)))) a h (append i (list (cons d (cdr vars)))) v))
						(error &quot;define-record-lambda: optional-field should precede automatic-field&quot; d)))
					   ((eq? 'unquote-splicing b) ;(,@c val)
					    (if (and (null? r) (null? o) (null? a) (null? v))
						(field-sort (cdr field)
							    fm (append fi (list (list d d))) (append c (list (list d d (cadr vars)))) r o a h i v)
						(error &quot;define-record-lambda: common-field should precede all the other fields&quot; d)))
					   (else
					    (error &quot;define-record-lambda: incorrect syntax&quot; vars))))
					 ((and (eq? 'unquote (car d)) (null? (cddr d)))
					  (if (symbol? (cadr d))
					      (cond
					       ((eq? 'quasiquote b) ;(`,a val)
						(field-sort (cdr field)
							    fm fi
							    c r o (append a (list (list (cadr d) (cadr d) (cadr vars)))) (append h (list (cons (cadr d) (cdr vars)))) i v))
					       ((eq? 'quote b) ;(',a val)
						(let ((t (gensym)))
						  (field-sort (cdr field)
							      fm (append fi (list (list (cadr d) t)))
							      c r o (append a (list (list (cadr d) t (cadr vars)))) h (append i (list (cons (cadr d) (cdr vars)))) v)))
					       ((eq? 'unquote b) ;(,,a val)
						(field-sort (cdr field)
							    fm (append fi (list (cons (cadr d) (cdr vars))))
							    c r o a h i (append v (list (cons (cadr d) (cdr vars))))))
					       (else
						(error &quot;define-record-lambda: incorrect syntax&quot; vars)))
					      (error &quot;define-record-lambda: incorrect syntax&quot; vars)))
					 ((and (eq? 'unquote-splicing (car d)) (null? (cddr d)))
					  (if (symbol? (cadr d))
					      (cond
					       ((eq? 'quasiquote b) ;(`,@c val)
						(if (and (null? r) (null? o) (null? a) (null? v))
						    (field-sort (cdr field)
								fm fi
								(append c (list (list (cadr d) (cadr d) (cadr vars)))) r o a (append h (list (cons (cadr d) (cdr vars)))) i v)
						    (error &quot;define-record-lambda: common-field should precede all the other fields&quot; (cadr d))))
					       ((eq? 'quote b) ;(',@c val)
						(if (and (null? r) (null? o) (null? a) (null? v))
						    (let ((t (gensym)))
						      (field-sort (cdr field)
								  fm (append fi (list (list (cadr d) t)))
								  (append c (list (list (cadr d) t (cadr vars)))) r o a h (append i (list (cons (cadr d) (cdr vars)))) v))
						    (error &quot;define-record-lambda: common-field should precede all the other fields&quot; (cadr d))))
					       (else
						(error &quot;define-record-lambda: incorrect syntax&quot; vars)))
					      (error &quot;define-record-lambda: incorrect syntax&quot; vars)))
					 (else
					  (error &quot;define-record-lambda: incorrect syntax&quot; vars))))
				      (error &quot;define-record-lambda: incorrect syntax&quot; vars)))
			      (if (and (null? (cdr var)) (null? (cddr b)))
				  (cond
				   ((and (eq? 'unquote (car b)) (symbol? (cadr b))) ;((,a) val)
				    (field-sort (cdr field)
						(append fm (cdr b)) fi
						c r o (append a (list (list (cadr b) (cadr b) (cadr vars)))) h i v))
				   ((and (eq? 'unquote-splicing (car b)) (symbol? (cadr b))) ;((,@c) val)
				    (if (and (null? r) (null? o) (null? a) (null? v))
					(field-sort (cdr field)
						    (append fm (cdr b)) fi
						    (append c (list (list (cadr b) (cadr b) (cadr vars)))) r o a h i v)
					(error &quot;define-record-lambda: common-field should precede all the other fields&quot; (cadr b))))
				   (else
				    (error &quot;define-record-lambda: incorrect syntax&quot; vars)))
				  (error &quot;define-record-lambda: incorrect syntax&quot; vars))))
			(error &quot;define-record-lambda: incorrect syntax&quot; vars))))))))
  (field-sort field '() '() '() '() '() '() '() '() '()))

;;; eof

</pre>
<h1>References</h1>
<pre>
[R6RS]	    Michael Sperber, R. Kent Dybvig, Matthew Flatt, and
	    Anton von Straaten:
	    Revised(6) Report on the Algorithmic Language Scheme
	    <a href="http://www.r6rs.org">http://www.r6rs.org</a>
[SRFI 9]    Richard Kelsey: Defining Record Type
	    <a href="http://srfi.schemers.org/srfi-9">http://srfi.schemers.org/srfi-9</a>
[SRFI 100]  Joo ChurlSoo: Define-lambda-object
	    <a href="http://srfi.schemers.org/srfi-100/">http://srfi.schemers.org/srfi-100/</a>

</pre>
<h1>Copyright</h1>

Copyright (c) 2012 Joo ChurlSoo.

<p>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ``Software''), to
deal in the Software without restriction, including without limitation the
rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
sell copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

<p>
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

<p>
THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</body>
</html>
