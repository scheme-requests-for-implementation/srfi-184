;;; define-record-lambda --- define-macro

(define err-str "define-record-lambda: invisible or immutable field")
(define-macro (unquote-get symbol args)
  (define (lp args)
    (if (null? args)
	`(error err-str ,symbol)
	(let ((arg (car args)))
	  (if (pair? arg)
	      `(if (eq? ,symbol ',(car arg))
		   ,(cadr arg)
		   ,(lp (cdr args)))
	      `(if (eq? ,symbol ',arg)
		   ,arg
		   ,(lp (cdr args)))))))
  (lp args))
;; (define-macro (unquote-get symbol args)
;;   (if (null? args)
;;	 `(error err-str ,symbol)
;;	 (let ((arg (car args)))
;;	(if (pair? arg)
;;	    `(if (eq? ,symbol ',(car arg))
;;		 ,(cadr arg)
;;		 (unquote-get ,symbol ,(cdr args)))
;;	    `(if (eq? ,symbol ',arg)
;;		 ,arg
;;		 (unquote-get ,symbol ,(cdr args)))))))

(define-macro (unquote-set! symbol new-val args)
  (define (lp args)
    (if (null? args)
	`(error err-str ,symbol)
	(let ((arg (car args)))
	  `(if (eq? ,symbol ',arg)
	       (set! ,arg ,new-val)
	       ,(lp (cdr args))))))
  (lp args))

(define-macro (seq-lambda r o body)
  (define (opt-seq z cls body)
    (if (null? cls)
	`(if (null? ,z)
	     ,body
	     (error "define-record-lambda: too many arguments" ,z))
	(let ((cl (car cls)))
	  `(let ((,(car cl) (if (null? ,z) ,(cadr cl) (car ,z)))
		 (,z (if (null? ,z) ,z (cdr ,z))))
	     ,(opt-seq z (cdr cls) body)))))
  (if (null? o)
      `(lambda ,r ,body)
      (let ((z (gensym)))
	`(lambda (,@r . ,z)
	   ,(opt-seq z o body)))))

(define (field-key z k d)
  (let ((x (car z)) (y (cdr z)))
    (if (null? y)
	(cons d z)
	(if (eq? k x)
	    y
	    (let lp ((head (list x (car y))) (tail (cdr y)))
	      (if (null? tail)
		  (cons d z)
		  (let ((x (car tail)) (y (cdr tail)))
		    (if (null? y)
			(cons d z)
			(if (eq? k x)
			    (cons (car y) (append head (cdr y)))
			    (lp (cons x (cons (car y) head)) (cdr y)))))))))))
(define-macro (field-key! z k d)
  (let ((x (gensym))
	(y (gensym))
	(head (gensym))
	(tail (gensym)))
    `(let ((,x (car ,z)) (,y (cdr ,z)))
       (if (null? ,y)
	   ,d
	   (if (eq? ,k ,x)
	       (begin (set! ,z (cdr ,y)) (car ,y))
	       (let lp ((,head (list ,x (car ,y))) (,tail (cdr ,y)))
		 (if (null? ,tail)
		     ,d
		     (let ((,x (car ,tail)) (,y (cdr ,tail)))
		       (if (null? ,y)
			   ,d
			   (if (eq? ,k ,x)
			       (begin
				 (set! ,z (append ,head (cdr ,y)))
				 (car ,y))
			       (lp (cons ,x (cons (car ,y) ,head)) (cdr ,y))))))))))))
(define-macro (key-lambda r o body)
  (define (opt-key z cls body)
    (if (null? cls)
	`(if (null? ,z)
	     ,body
	     (error "define-record-lambda: too many arguments" ,z))
	(let ((cl (car cls)))
	  (let ((key (car cl)) (var (cadr cl)) (val (caddr cl)))
	    `(let ((,var (if (null? ,z) ,val (field-key! ,z ',key ,val))))
	    ;; `(let* ((,z (if (null? ,z) (cons ,val ,z) (field-key ,z ',key ,val)))
	    ;;	    (,var (car ,z))
	    ;;	    (,z (cdr ,z)))
	       ,(opt-key z (cdr cls) body))))))
  (if (null? o)
      `(lambda ,r ,body)
      (let ((z (gensym)))
	`(lambda (,@r . ,z) ,(opt-key z o body)))))

(define (check-duplicate ls err-str)
  (cond ((null? ls) #f)
	((memq (car ls) (cdr ls)) (error err-str (car ls)))
	(else (check-duplicate (cdr ls) err-str))))

(define (number-alist ls)
  (let loop ((ls ls) (n 0))
    (if (null? ls)
	'()
	(cons (cons (car ls) n) (loop (cdr ls) (+ 1 n))))))

(define-macro (define-lambda name fm fi c r o a h i v)
  (let ((arg (gensym))
	;; (val (gensym))
	(args (gensym))
	(maker (gensym))
	(maker/s (gensym))
	(v-all (gensym))
	(name-alist-m (gensym))
	(name-alist-a (gensym))
	(num-m (gensym))
	(num-a (gensym))
	(safe (gensym))
	(unique-name (gensym))
	(nm-str (symbol->string name)))
    (let ((make-record (string->symbol (string-append "make-" nm-str)))
	  (make-record-by-name (string->symbol (string-append "make-" nm-str "-by-name")))
	  (make-record/s (string->symbol (string-append "make-" nm-str "/s")))
	  (make-record-by-name/s (string->symbol (string-append "make-" nm-str "-by-name/s")))
	  (pred-record (string->symbol (string-append nm-str "?")))
	  (name-fm (map (lambda (x) (string->symbol (string-append nm-str "-" (symbol->string x)))) fm))
	  (name-fi (map (lambda (x) (string->symbol (string-append nm-str "-" (symbol->string x)))) (map car fi))))
      `(begin
	 ;; A vector or list can be used instead of unquote-get & unquote-set!.
	 ;; cf. (eval-variant expression implementation-specific-namespace)

	 (define ,name-alist-a (number-alist ',(append name-fm name-fi)))
	 (define ,name-alist-m (number-alist ',name-fm))
	 (define ,num-a (length ,name-alist-a))
	 (define ,num-m (length ,name-alist-m))
	 ,@(map (lambda (f) `(define ,f (cdr (assq ',f ,name-alist-a)))) name-fi)
	 ,@(map (lambda (f) `(define ,f (cdr (assq ',f ,name-alist-m)))) name-fm)

	 ;; You can choose a suitable constructor.
	 ;; 1. number
	 (define ,maker
	   (let* ,(map cdr c)
	     (cons (seq-lambda ,(map cadr r) ,(map cdr o)
		     (let* ,(map cdr a)
		       (define ,unique-name
			 (if (and (null? ',c) (null? ',o) (null? ',a) (null? ',v))
			     (let ((,v-all (vector ,@fm ,@(map cadr fi))))
			       (cond
				((null? ',fi)
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (vector-set! ,v-all ,arg ,val))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (vector-set! ,v-all ,arg (car ,args)))))
				((null? ',fm)
				 (lambda (,arg) (vector-ref ,v-all ,arg)))
				(else
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (if (< ,arg ,num-m)
				 ;;		   (vector-set! ,v-all ,arg ,val)
				 ;;		   (error err-str ,arg)))))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (if (< ,arg ,num-m)
					   (vector-set! ,v-all ,arg (car ,args))
					   (error err-str ,arg)))))))
			     (let ((,v-all (vector ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (set! ,f ,safe)))) fm) ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (error ,err-str)))) (map cadr fi)))))
			       ;; (case-lambda
			       ;;	((,arg) ((vector-ref ,v-all ,arg) ',unique-name))
			       ;;	((,arg ,val) ((vector-ref ,v-all ,arg) ,val))))))
			       (lambda (,arg . ,args)
				 (if (null? ,args)
				     ((vector-ref ,v-all ,arg) ',unique-name)
				     ((vector-ref ,v-all ,arg) (car ,args)))))))
		       ,unique-name))
		   (key-lambda ,(map cadr r) ,o
		     (let* ,(map cdr a)
		       (define ,unique-name
			 (if (and (null? ',c) (null? ',o) (null? ',a) (null? ',v))
			     (let ((,v-all (vector ,@fm ,@(map cadr fi))))
			       (cond
				((null? ',fi)
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (vector-set! ,v-all ,arg ,val))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (vector-set! ,v-all ,arg (car ,args)))))
				((null? ',fm)
				 (lambda (,arg) (vector-ref ,v-all ,arg)))
				(else
				 ;; (case-lambda
				 ;;  ((,arg) (vector-ref ,v-all ,arg))
				 ;;  ((,arg ,val) (if (< ,arg ,num-m)
				 ;;		   (vector-set! ,v-all ,arg ,val)
				 ;;		   (error err-str ,arg)))))))
				 (lambda (,arg . ,args)
				   (if (null? ,args)
				       (vector-ref ,v-all ,arg)
				       (if (< ,arg ,num-m)
					   (vector-set! ,v-all ,arg (car ,args))
					   (error err-str ,arg)))))))
			     (let ((,v-all (vector ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (set! ,f ,safe)))) fm) ,@(map (lambda (f) `(lambda (,safe) (if (eq? ,safe ',unique-name) ,f (error ,err-str)))) (map cadr fi)))))
			       ;; (case-lambda
			       ;;	((,arg) ((vector-ref ,v-all ,arg) ',unique-name))
			       ;;	((,arg ,val) ((vector-ref ,v-all ,arg) ,val))))))
			       (lambda (,arg . ,args)
				 (if (null? ,args)
				     ((vector-ref ,v-all ,arg) ',unique-name)
				     ((vector-ref ,v-all ,arg) (car ,args)))))))
		       ,unique-name)))))
	 (define ,make-record (car ,maker))
	 (define ,make-record-by-name (cdr ,maker))

	 ;; 2. symbol
	 (define ,maker/s
	   (let* ,(map cdr c)
	     (cons (seq-lambda ,(map cadr r) ,(map cdr o)
		     (let* ,(map cdr a)
		       (define ,unique-name
			 ;; (case-lambda
			 ;;  ((,arg) (unquote-get ,arg ,(append (map list fm fm) fi)))
			 ;;  ((,arg ,val) (unquote-set! ,arg ,val ,fm))))
			 (lambda (,arg . ,args)
			   (if (null? ,args)
			       (unquote-get ,arg ,(append (map list fm fm) fi))
			       (unquote-set! ,arg (car ,args) ,fm))))
		       ,unique-name))
		   (key-lambda ,(map cadr r) ,o
		     (let* ,(map cdr a)
		       (define ,unique-name
			 ;; (case-lambda
			 ;;  ((,arg) (unquote-get ,arg ,(append (map list fm fm) fi)))
			 ;;  ((,arg ,val) (unquote-set! ,arg ,val ,fm))))
			 (lambda (,arg . ,args)
			   (if (null? ,args)
			       (unquote-get ,arg ,(append (map list fm fm) fi))
			       (unquote-set! ,arg (car ,args) ,fm))))
		       ,unique-name)))))
	 (define ,make-record/s (car ,maker/s))
	 (define ,make-record-by-name/s (cdr ,maker/s))

	 ;; The predicate procedure is implementation dependant.
	 ;; A procedure such as `object-name' is necessary for this to work.

	 (define (,pred-record record)	;racket
	   (eq? ',unique-name (object-name record)))

	 (define ,name
	   (let ((constructor `(,,maker ,,maker/s))
		 (predicate ,pred-record)
		 (field `((total (read-write-field ,',fm)
				 (read-only-field ,',(map car fi))
				 (invisible-field ,',(map car h)))
			  (types (common-field ,',(map car c))
				 (required-field ,',(map car r))
				 (optional-field ,',(map car o))
				 (automatic-field ,',(append (map car a) (map car v)))
				 (immutable-field ,',(map car i))
				 (invisible-field ,',(map car h))
				 (virtual-field ,',(map car v)))))
		 (index ,name-alist-a))
	     (check-duplicate ',(append fm (map car fi) (map car h))
			      "define-record-lambda: duplicated field")
	     (lambda (sym)
	       (unquote-get sym (constructor predicate field index)))))))))

(define-macro (define-record-lambda name . field)
  (define (field-sort field fm fi c r o a h i v)
    (if (null? field)
	`(define-lambda ,name ,fm ,fi ,c ,r ,o ,a ,h ,i ,v)
	(let ((vars (car field)))
	  (if (symbol? vars)		;r
	      (if (and (null? o) (null? a) (null? v))
		  (field-sort (cdr field)
			      fm (append fi (list (list vars vars)))
			      c (append r (list (list vars vars))) o a h i v)
		  (error "define-record-lambda: required-field should precede optional-field and automatic-field" vars))
	      (let ((var (car vars)))
		(if (symbol? var)
		    (if (null? (cdr vars)) ;(r)
			(if (and (null? o) (null? a) (null? v))
			    (field-sort (cdr field)
					(append fm vars) fi
					c (append r (list (list (car vars) (car vars)))) o a h i v)
			    (error "define-record-lambda: required-field should precede optional-field and automatic-field" var))
			(if (null? (cddr vars)) ;(var val)
			    (if (and (null? a) (null? v))
				(cond
				 ((eq? 'quasiquote var)
				  (if (null? o)	;`r
				      (let ((rva (cadr vars)))
					(field-sort (cdr field)
						    fm fi
						    c (append r (list (list rva rva))) o a (append h (list (list rva rva))) i v))
				      (error "define-record-lambda: required-field should precede optional-field" var)))
				 ((eq? 'quote var)
				  (if (null? o)	;'r
				      (let ((t (gensym)) (rva (cadr vars)))
					(field-sort (cdr field)
						    fm (append fi (list (list rva t)))
						    c (append r (list (list rva t))) o a h (append i (list (list rva rva))) v))
				      (error "define-record-lambda: required-field should precede optional-field" var)))
				 (else	;(o val)
				  (field-sort (cdr field)
					      fm (append fi (list (list var var)))
					      c r (append o (list (cons var vars))) a h i v)))
				(error "define-record-lambda: required-field and optional-field should precede automatic-field" var))
			    (error "define-record-lambda: incorrect syntax" vars)))
		    (if (and (pair? (cdr vars)) (null? (cddr vars)))
			(let ((b (car var)))
			  (if (symbol? b)
			      (if (null? (cdr var)) ;((o) val)
				  (if (and (null? a) (null? v))
				      (field-sort (cdr field)
						  (append fm var) fi
						  c r (append o (list (list b b (cadr vars)))) a h i v)
				      (error "define-record-lambda: optional-field should precede automatic-field" b))
				  (if (null? (cddr var))
				      (let ((d (cadr var)))
					(cond
					 ((symbol? d)
					  (cond
					   ((eq? 'unquote b) ;(,a val)
					    (field-sort (cdr field)
							fm (append fi (list (list d d)))
							c r o (append a (list (list d d (cadr vars)))) h i v))
					   ((eq? 'quasiquote b) ;(`o val)
					    (if (and (null? a) (null? v))
						(field-sort (cdr field)
							    fm fi
							    c r (append o (list (list d d (cadr vars)))) a (append h (list (cons d (cdr vars)))) i v)
						(error "define-record-lambda: optional-field should precede automatic-field" d)))
					   ((eq? 'quote b) ;('o val)
					    (if (and (null? a) (null? v))
						(let ((t (gensym)))
						  (field-sort (cdr field)
							      fm (append fi (list (list d t)))
							      c r (append o (list (list d t (cadr vars)))) a h (append i (list (cons d (cdr vars)))) v))
						(error "define-record-lambda: optional-field should precede automatic-field" d)))
					   ((eq? 'unquote-splicing b) ;(,@c val)
					    (if (and (null? r) (null? o) (null? a) (null? v))
						(field-sort (cdr field)
							    fm (append fi (list (list d d))) (append c (list (list d d (cadr vars)))) r o a h i v)
						(error "define-record-lambda: common-field should precede all the other fields" d)))
					   (else
					    (error "define-record-lambda: incorrect syntax" vars))))
					 ((and (eq? 'unquote (car d)) (null? (cddr d)))
					  (if (symbol? (cadr d))
					      (cond
					       ((eq? 'quasiquote b) ;(`,a val)
						(field-sort (cdr field)
							    fm fi
							    c r o (append a (list (list (cadr d) (cadr d) (cadr vars)))) (append h (list (cons (cadr d) (cdr vars)))) i v))
					       ((eq? 'quote b) ;(',a val)
						(let ((t (gensym)))
						  (field-sort (cdr field)
							      fm (append fi (list (list (cadr d) t)))
							      c r o (append a (list (list (cadr d) t (cadr vars)))) h (append i (list (cons (cadr d) (cdr vars)))) v)))
					       ((eq? 'unquote b) ;(,,a val)
						(field-sort (cdr field)
							    fm (append fi (list (cons (cadr d) (cdr vars))))
							    c r o a h i (append v (list (cons (cadr d) (cdr vars))))))
					       (else
						(error "define-record-lambda: incorrect syntax" vars)))
					      (error "define-record-lambda: incorrect syntax" vars)))
					 ((and (eq? 'unquote-splicing (car d)) (null? (cddr d)))
					  (if (symbol? (cadr d))
					      (cond
					       ((eq? 'quasiquote b) ;(`,@c val)
						(if (and (null? r) (null? o) (null? a) (null? v))
						    (field-sort (cdr field)
								fm fi
								(append c (list (list (cadr d) (cadr d) (cadr vars)))) r o a (append h (list (cons (cadr d) (cdr vars)))) i v)
						    (error "define-record-lambda: common-field should precede all the other fields" (cadr d))))
					       ((eq? 'quote b) ;(',@c val)
						(if (and (null? r) (null? o) (null? a) (null? v))
						    (let ((t (gensym)))
						      (field-sort (cdr field)
								  fm (append fi (list (list (cadr d) t)))
								  (append c (list (list (cadr d) t (cadr vars)))) r o a h (append i (list (cons (cadr d) (cdr vars)))) v))
						    (error "define-record-lambda: common-field should precede all the other fields" (cadr d))))
					       (else
						(error "define-record-lambda: incorrect syntax" vars)))
					      (error "define-record-lambda: incorrect syntax" vars)))
					 (else
					  (error "define-record-lambda: incorrect syntax" vars))))
				      (error "define-record-lambda: incorrect syntax" vars)))
			      (if (and (null? (cdr var)) (null? (cddr b)))
				  (cond
				   ((and (eq? 'unquote (car b)) (symbol? (cadr b))) ;((,a) val)
				    (field-sort (cdr field)
						(append fm (cdr b)) fi
						c r o (append a (list (list (cadr b) (cadr b) (cadr vars)))) h i v))
				   ((and (eq? 'unquote-splicing (car b)) (symbol? (cadr b))) ;((,@c) val)
				    (if (and (null? r) (null? o) (null? a) (null? v))
					(field-sort (cdr field)
						    (append fm (cdr b)) fi
						    (append c (list (list (cadr b) (cadr b) (cadr vars)))) r o a h i v)
					(error "define-record-lambda: common-field should precede all the other fields" (cadr b))))
				   (else
				    (error "define-record-lambda: incorrect syntax" vars)))
				  (error "define-record-lambda: incorrect syntax" vars))))
			(error "define-record-lambda: incorrect syntax" vars))))))))
  (field-sort field '() '() '() '() '() '() '() '() '()))

;;; eof
